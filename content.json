[{"title":"在Java中使用正则表达式","date":"2017-08-13T12:53:20.000Z","path":"posts/cb6fd708/","text":"我对正则表达式的理解正则表达式Regex(Regular Expression)，是一种通过定义由特定字符组成的表达式来对字符串进行匹配、查找、替换和切割的字符串操作工具。 正则表达式中特定的一些字符 表达式 匹配内容 字符 x 字符 x \\ 反斜线字符 \\0n 带有八进制值 0 的字符 n (0 &lt;= n &lt;= 7) \\0nn 带有八进制值 0 的字符 nn (0 &lt;= n &lt;= 7) \\0mnn 带有八进制值 0 的字符 mnn（0 &lt;= m &lt;= 3、0 &lt;= n &lt;= 7） \\xhh 带有十六进制值 0x 的字符 hh \\uhhhh 带有十六进制值 0x 的字符 hhhh \\t 制表符 (‘\\u0009’) \\n 新行（换行）符 (‘\\u000A’) \\r 回车符 (‘\\u000D’) \\f 换页符 (‘\\u000C’) \\a 报警 (bell) 符 (‘\\u0007’) \\e 转义符 (‘\\u001B’) \\cx 对应于 x 的控制符 字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \\d 数字：[0-9] \\D 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] 边界匹配器 ^ 行的开头 $ 行的结尾 \\b 单词边界 \\B 非单词边界 \\A 输入的开头 \\G 上一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符（如果有的话） \\z 输入的结尾 Greedy数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 正则表达式在Java中的表现形式123public final class Patternextends Objectimplements Serializable Pattern正则表达式的编译表示形式。 指定为字符串的正则表达式必须首先被编译为此类的实例。然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。 因此，典型的调用顺序是 123Pattern p = Pattern.compile(&quot;a*b&quot;);Matcher m = p.matcher(&quot;aaaaab&quot;);boolean b = m.matches(); 在仅使用一次正则表达式时，可以方便地通过此类定义 matches 方法。此方法编译表达式并在单个调用中将输入序列与其匹配。语句 1boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;); 等效于上面的三个语句，尽管对于重复的匹配而言它效率不高，因为它不允许重用已编译的模式。 使用正则表达式对字符串进行匹配使用正则表达式对字符串进行匹配有三种方式：1）使用字符串的对象的matches()方法2）使用Matcher的对象的matches()方法3）使用Pattern类的matches()方法匹配的特点：1）根据正则表达式的规则对整个字符串进行匹配2）匹配结果返回对应的布尔值使用方法：请参考下面匹配字符串是否为电话号码的实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MatchTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;一，使用字符串的对象的matches()方法&quot;); matchDemo_1(&quot;13805646681&quot;); matchDemo_1(&quot;03805646681&quot;); matchDemo_1(&quot;13805Jia681&quot;); matchDemo_1(&quot;138056&quot;); System.out.println(&quot;二，使用Matcher的对象的matches()方法&quot;); matchDemo_2(&quot;13805646681&quot;); matchDemo_2(&quot;03805646681&quot;); matchDemo_2(&quot;13805Jia681&quot;); matchDemo_2(&quot;138056&quot;); System.out.println(&quot;三，使用Pattern类的matches()方法&quot;); matchDemo_3(&quot;13805646681&quot;); matchDemo_3(&quot;03805646681&quot;); matchDemo_3(&quot;13805Jia681&quot;); matchDemo_3(&quot;138056&quot;); &#125; /** * 匹配字符串是否为电话号码 * 匹配规则： * 1.电话号码以数字1开头 * 2.电话号码长度为11 * 3.电话号码为全数字 * 对应的正则表达式： * 1)&quot;1\\\\d&#123;10&#125;&quot; * 解读： * 正则表达是第一个数是1，所以它只能匹配以1开头的字符串； * \\\\d，因为Java中反斜杠会把它后面的字符进行转移，所以\\\\d就是正则表达式中预定义字符类中的\\d(== [0-9]),即能够匹配数字0-9中的任意一个； * &#123;10&#125;，代表前面的\\d恰好出现10次，这样加上第一个数1共有11个数字，所以它只能匹配长度为11且全部为数字的字符串。 * 2)&quot;1[0-9]&#123;10&#125;&quot; * 解读： * \\d == [0-9] */ public static void matchDemo_1(String str) &#123; String regex = &quot;1\\\\d&#123;10&#125;&quot;; boolean isMatched = str.matches(regex); System.out.println(str + (isMatched ? &quot;是电话号码&quot; : &quot;不是电话号码&quot;)); &#125; public static void matchDemo_2(String str) &#123; String regex = &quot;1[0-9]&#123;10&#125;&quot;; // 1，将正则表达式编译成Pattern对象 Pattern p = Pattern.compile(regex); // 2, 与字符串进行关联，生成Matcher对象 Matcher m = p.matcher(str); // 3，对字符串进行操作 boolean isMatched = m.matches(); System.out.println(str + (isMatched ? &quot;是电话号码&quot; : &quot;不是电话号码&quot;)); &#125; public static void matchDemo_3(String str) &#123; String regex = &quot;1\\\\d&#123;10&#125;&quot;; boolean isMatched = Pattern.matches(regex, str); System.out.println(str + (isMatched ? &quot;是电话号码&quot; : &quot;不是电话号码&quot;)); &#125;&#125; 使用正则表达式对字符串进行替换正则表达式既可以替换字符串中所有匹配到的字符，也可以只替换第一次匹配到的字符，对应的两个方法是replaceALL和replaceFirst,同样在String对象和Matcher对象中都包含这两个方法。替换的特点：1）可以将正则表达式匹配到的字符(串)替换为你指定的字符(串)2）替换结果生成新的字符串使用方法：请参考下面叠词替换的实例 1234567891011121314151617181920212223242526272829303132public class StackedWordsReplace &#123; public static void main(String[] args) &#123; stackedWordsReplaceDemo_1(); stackedWordsReplaceDemo_2(); &#125; public static void stackedWordsReplaceDemo_1() &#123; // 将下面的字符串转换成&quot;我要学习编程。&quot; String str = &quot;我我我我我要要学学学编编编编程程程程。&quot;; // 正则表达式中通过()创建一个捕获组 // 捕获组默认从1开始进行编号，可以通过从左到右计算开括号（左括号）个数和顺序进行排序 // 例如，在表达式 ((A)(B(C))) 中，存在四个这样的组：((A)(B(C)))、(A)、(B(C))、(C) // 正则表达式中的\\n和$n分别在匹配环节和替换环节中引用捕获组捕获的内容，n代表数字1、2、3... // &quot;(.)\\1+&quot;解读： // .可以匹配任意字符,\\\\1即\\1引用(.)的捕获内容，+前面的字符出现一次或多次。 // 比如,当.匹配的到我的时候\\1就是我，所以这个表达式能够匹配到无数个我连续组成但最低不少两个我的字符串。 // $1为替换的类容，因为$1引用(.)的捕获内容，所以当.匹配到什么就替换为什么 str = str.replaceAll(&quot;(.)\\\\1+&quot;, &quot;$1&quot;); System.out.println(str); &#125; public static void stackedWordsReplaceDemo_2() &#123; String str = &quot;我我我我我要要学学学编编编编程程程程。&quot;; String regex = &quot;(.)\\\\1+&quot;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(str); str = matcher.replaceAll(&quot;$1&quot;); System.out.println(str); &#125;&#125; 使用正则表达式对字符串进行切割使用正则表达式对字符串进行分割有两种方式：1）使用String对象的split方法2）使用Pattern对象的split方法分割的特点：1）可以将正则表达式匹配到的字符(串)作为分隔符来对字符串进行分割2）分割结果为子串组成的字符串数组使用方法：请参考下面的分割实例 12345678910111213141516171819202122232425262728public class SplitTest &#123; public static void main(String[] args) &#123; splitDemo_1(); splitDemo_2(); &#125; public static void splitDemo_1() &#123; // 将下面的字符串以.为分隔符进行分割 // 由于在正则表达式中.为预定义字符，所以需要用\\进行转义， // 在Java中\\也是转义字符，所以仍需要进行转义 String str = &quot;我.爱.中.国&quot;; String regex = &quot;\\\\.&quot;; String[] strings = str.split(regex); for (String s : strings) &#123; System.out.println(s); &#125; &#125; public static void splitDemo_2() &#123; String str = &quot;我.爱.中.国&quot;; String regex = &quot;\\\\.&quot;; Pattern pattern = Pattern.compile(regex); String[] strings = pattern.split(str); for (String s : strings) &#123; System.out.println(s); &#125; &#125;&#125; 综合案例演示下面将演示综合使用和分割来对IP地址进行排序 1234567891011121314151617181920212223242526272829public class IPSort &#123; public static void main(String[] args) &#123; ipSort(); &#125; /** * 将IP地址进行排序 */ public static void ipSort() &#123; String ip = &quot;127.0.0.1 192.168.0.1 114.114.114.114 8.8.8.8 10.2.33.134 255.255.255.255&quot;; // 1.将IP地址全部替换为xxx.xxx.xxx.xxx样式 ip = ip.replaceAll(&quot;\\\\w&#123;1,3&#125;&quot;, &quot;00$0&quot;); // 将IP地址每一段都添加00 System.out.println(ip); ip = ip.replaceAll(&quot;0*(\\\\w&#123;3&#125;)&quot;, &quot;$1&quot;); // 去除每一段多余的0，是每一段只保留三位数字 System.out.println(ip); // 2.对字符串进行排序 String[] arr = ip.split(&quot; &quot;); System.out.println(Arrays.toString(arr)); Arrays.sort(arr); for (String s : arr) &#123; // 去除添加的0 s = s.replaceAll(&quot;0*(\\\\w+)&quot;, &quot;$1&quot;); System.out.println(s); &#125; &#125;&#125; 使用正则表达式对字符串进行查找对字符串进行查找，主要用的是Matcher对象的以下方法：1）find()尝试查找与该模式匹配的输入序列的下一个子序列2）group()返回上一次匹配操作所匹配的输入子序列3）reset(CharSequence input)将该模式应用到新的输入序列查找的特点：1）可以将正则表达式匹配到的字符(串)逐个找出来2）查找结果为一个个匹配的子串3）必须逐个查找，直接调用group()方法无法得到结果使用方法：请参考下面的爬去网页中的电子邮箱实例 123456789101112131415161718192021222324252627282930313233343536public class FindEmail &#123; public static void main(String[] args) &#123; findEmail(); &#125; public static void findEmail() &#123; // 简单邮箱匹配规则 String reg = &quot;\\\\w+@\\\\w+(\\\\.\\\\w+)+&quot;; // 1.将正则表达式编译成Pattern对象 Pattern p = Pattern.compile(reg); Matcher m = null; try &#123; URL url = new URL(&quot;https://www.douban.com/group/topic/70867518/&quot;); URLConnection connection = url.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line = null; while ((line = br.readLine()) != null) &#123; // 2.将字符串和Pattern对象进行关联,生成Matcher对象 if (m == null) &#123; m = p.matcher(line); &#125; else &#123; m.reset(line); &#125; // 3.通过Matcher对象对字符串进行操作 while (m.find()) &#123; System.out.println(m.group()); &#125; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yanqinming.cn/tags/Java/"},{"name":"Regex","slug":"Regex","permalink":"http://yanqinming.cn/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yanqinming.cn/tags/正则表达式/"}]},{"title":"Hexo博客搭建之SEO搜索优化","date":"2017-07-24T06:29:26.000Z","path":"posts/3bc7d02e/","text":"什么是 SEO？SEO 全称是 Search Engine Optimization，即搜索引擎优化。具体一点，就是说通过一些优化手段使得我们的博客的文章被搜索引擎收录（使我们的文章能够被其他人搜索到）以及在搜索引擎的排名更靠前。 为什么要做 SEO 搜索优化？举个栗子，你同时在个人博客和其他博客平台发表同一篇文章，然后你在搜索引擎中搜索你发布文章，你会发现在其他博客平台发布的文章你能很快找到，而在个人博客发表的同一篇文章有可能排名靠后很难找到，或者根本就搜索不到。 如何做 SEO 优化？这里我们主要介绍的是通过向搜索引擎提交站点地图 sitemap（可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页）的方式。下面我就为大家演示一下，如何向 Google 提交我们的 sitemap。 首先，利用 hexo 插件来为我们的博客自动生成 sitemap通过下面的操作安装配置好插件，在以后生成部署博客时就会自动为我们在网站的根目录下创建一个sitemap.xml文件。我们可以通过http://你的网站地址/sitemap.xml来访问这个文件，比如我的博客sitemap访问地址为http://yanqinming.cn/sitemap.xml 1) 安装插件 1npm install hexo-generator-sitemap --save 2) 配置插件 在站点配置文件(_config.yml)中添加如下代码 12sitemap:path: sitemap.xml 其次，向 Google 提交 sitemap这里我先教大家如何判断自己的网站是否已经被搜索引擎收录，方法很简单，比如我想知道 Google 是否收录了我的博客，我只需要在 Google 的搜索框中敲入这段代码即可。 1234格式形同：site:(your domain)比如我的博客就是：site:yanqinming.cn 下面分别是我在 google 和 baidu 的实验结果截图，很明显我的博客网站已经被 google 收录了却没有被 baidu 收录，所以我在百度中是搜索不到我的博客文章的。（事实上，我向两个搜索引擎都提交了相对应的 sitemap，但是由于 GitHub 禁止了百度对 Pages 的爬取，所以百度依然搜索不到数据。解决方案，是使用百度的主动推送和自动推送。）下面，我们正式开始介绍如何向 google 提交 sitemap。在上面第一张 google 的搜索截图中，我们看到第一条搜索结果和其他几条不同，点击进入就可以通过 Google Search Console 向 google 提交我们的博客网站的 sitemap。 1）登录谷歌账号 2）添加属性，如下图填入自己博客网站对应地址，然后点击添加属性提交 3）验证的您是网站的拥有者。这里我们选择HTML文件上传的方式，点击下载此 HTML 验证文件，下载验证文件，将它移动到我们的博客的source文件夹下，重新部署生成我们的博客，然后点击刚才页面最下方的验证按钮进行验证。接着，你会发现验证失败，因为 hexo 会对我们放在source文件夹下的文件进行处理（添加网页头部、评论等）。解决方案是在博客的配置文件中设置 skip_render，我采用的是最简单粗暴的方式，即设置对 source 文件夹下的所有html文件不做处理，具体代码为skip_render: &#39;*.html&#39;。设置完成后，按照上面的方式重新进行验证就可以了。 4）提交 sitemap。上一步验证成功以后，点击继续就会跳转到下面的页面，点击下图中右下角的站点地图进行下一步操作。点击右上角的的添加／测试站点地图的红色按钮，在输入框中填入 sitemap.xml，然后点击提交按钮即可。提交成功后，刷新页面如下图。 最后，过段时间（不会立即显示）利用上一步判断网站是否被收录的方法进行验证。总结上面演示了如何向 google 提交 sitemap 来优化博客在 google 搜索结果，向其他搜索引擎提交 sitemap 的原理相同，你可以尝试一下向百度提交飞机直达。前面我们也提到了GitHub Pages 禁止了百度爬虫爬取的解决方案，具体方法请您自行Google或者百度一下。其他的SEO优化方案，我了解的有：1）文章链接唯一化，请搜索“hexo-abbrlink”2）添加蜘蛛协议，请搜索“hexo robots.txt”3）限制出站链接,请搜索“hexo-autonofollow”","tags":[{"name":"Hexo博客搭建","slug":"Hexo博客搭建","permalink":"http://yanqinming.cn/tags/Hexo博客搭建/"},{"name":"SEO搜索优化","slug":"SEO搜索优化","permalink":"http://yanqinming.cn/tags/SEO搜索优化/"}]},{"title":"JDBC简单使用总结","date":"2017-07-22T02:28:50.000Z","path":"posts/7933063e/","text":"什么是 JDBC？JDBC 的全称是 Java Database Connectivity，即Java数据库连接，它是一种可以执行 SQL 语句的 Java API。 为什么要使用 JDBC？通过使用 JDBC，就可以使用同一种 API 访问不同的数据库系统。换言之，无论你使用什么类型的数据库，只要根据 JDBC API 编写一套数据库操作逻辑。 如何使用 JDBC 去操作数据库？1，加载数据库驱动。12// 加载驱动Class.forName(driverClass); 例如加载 MySQL 驱动，首先搜索“MySQL JDBC 驱动”下载驱动jar包，然后导入到工程中，最后在 Java 代码中调用。 12// 加载 MySQL 驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 2，通过 DriverManager 获取数据库连接12// 获取数据库连接DriverManager.getConnection(String url, String user, String password); 例如我想连接我的 MySQL 数据库中的 Test 数据库 1234String url = &quot;jdbc:mysql://127.0.0.1:3306/Test&quot;; // 连接指定数据库的 URL，不同数据库的连接 URL，可通过查看相应的数据库驱动文档String user = &quot;root&quot;; // 登录数据库的用户名String password = &quot;123456&quot;; // 登录数据库的密码Connection conn = DriverManager.getConnection(url, user, password); // 返回 Connection 对象 3，通过 Connection 对象创建 Statement 对象12// 这里我们创建一个基本的 Statement 对象Statement stmt = conn.createStatement(); 4，使用 Statement 执行 SQL 语句12345// Statement 有三种执行 SQL 语句的方法,通常我们使用比较多的是executeQuery()方法，// 执行 select 方法，返回查询到的结果集 ResultSet。String selectSql = &quot;select * from table1&quot;;ResultSet rs = stmt.executeQuery(selectSql);*/ 5，对执行结果进行处理1234567// 通常使用 while 循环对结果进行遍历，// 并在循环体中通过 ResultSet 的一系列getXxx(列索引 or 列名)// 来获取查询表中指定列的值，进行业务逻辑处理。while (rs.next()) &#123; // 比如这里我对结果进行输出打印 System.out.println(rs.getString(1) + rs.getInt(1));&#125; 6，回收数据库资源，包括关闭ResultSet、Statement和Connection等资源。123rs.close();stmt.close();conn.close();","tags":[{"name":"Java数据库连接","slug":"Java数据库连接","permalink":"http://yanqinming.cn/tags/Java数据库连接/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yanqinming.cn/tags/JDBC/"}]},{"title":"使用XML定义选项菜单","date":"2017-07-21T01:28:37.000Z","path":"posts/a4a7bc15/","text":"何为选项菜单？ 选项菜单是某个Activity的主菜单项，供您放置对应用产生全局影响的操作，如“搜索”、“撰写电子邮件”和设置。选项菜单中的项目在屏幕上的显示位置取决于您开发应用所使用的 Android 版本： 如果您开发的应用适用于 Android 2.3.x （API 级别10）或更低版本，选项菜单的内容会出现在屏幕底部如下图所示，且当菜单项超过6个时，则会讲第六项和其余项目放入溢出菜单（即图中的 More 菜单项）中。 如果您开发的应用适用于 Android 3.0 （API 级别 11）及更高版本，选项菜单的内容将出现在应用栏中如下图所示。默认情况下，系统会将所有的菜单项放入操作溢出菜单（即图中标号为3的菜单项）中。 创建menu资源文件首先我在 app/src/mian/res/menu/ 目录下创建一个 my_menu.xml 文件 内容如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;item1&quot;/&gt; &lt;item android:id=&quot;@+id/item2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;item2&quot;/&gt; &lt;group android:id=&quot;@+id/group&quot; android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/group_item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;group_item1&quot;/&gt; &lt;item android:id=&quot;@+id/group_item2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;group_item2&quot;/&gt; &lt;/group&gt; &lt;item android:id=&quot;@+id/submenu&quot; android:title=&quot;submenu_title&quot;&gt; &lt;menu&gt; &lt;item android:id=&quot;@+id/submenu_item1&quot; android:title=&quot;submenu_item1&quot;/&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 从代码中我们可以看出，菜单资源文件以&lt;menu&gt;为根节点，使用&lt;item&gt;元素来定义菜单项。同时，我们也可以选择使用&lt;group&gt;元素来定义一个组，来对组内的菜单项的一些特性进行统一的修改，比如是否可见。最后，可以看到我们以在&lt;item&gt;元素中嵌套&lt;menu&gt;元素的方式来创建子菜单。 &lt;item&gt;元素的常用属性： android:id 为菜单项指定一个唯一标识 android:title 指定菜单项的标题 android:icon 指定菜单项的图标 android:showAsAction 指定菜单项作为操作项目显示在应用栏的时间和方式 &lt;group&gt;元素的常用属性 android:id 为改组菜单指定一个唯一标识 android:checkableBehavior 指定改组菜单的选择行为 android:visible 指定改组菜单是否可见 android:enable 指定改组菜单是否可用 更详细的介绍请参考API文档Menu部分。 加载menu资源文件通过重写 onCreateOptionsMenu() 方法，来为 Activity 指定选项菜单。 123456789101112131415public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.my_menu, menu); return true; &#125;&#125; 运行效果： 处理点击事件当我们从选项菜单中选择项目时，系统将调用 Activity 的 onOptionsItemSelected() 方法。 此方法将传递所选的 MenuItem，可以通过调用 getItemId() 方法来识别项目，该方法将返回菜单项的唯一 ID（由菜单资源中的 android:id 属性定义）。 我们可以将此 ID 与已知的菜单项匹配，以执行适当的操作。例如： 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.my_menu, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.group_item1: item.setChecked(true); return true; case R.id.group_item2: item.setChecked(true); return true; default: Toast.makeText(this, &quot;selected &quot; + item.getTitle(), Toast.LENGTH_SHORT).show(); return super.onOptionsItemSelected(item); &#125; &#125;&#125; 运行效果： 总结本文主要初步的介绍了如何使用 XML 定义选项菜单，定义其他类型菜单的方法类似。更深入的了解和使用菜单请参考Android官方教程。关于即便设置showAsAction=”always”，items仍然在overflow中显示的问题，请参考这篇文章。 ps:欢迎留言交流，共同进步。","tags":[{"name":"android","slug":"android","permalink":"http://yanqinming.cn/tags/android/"}]},{"title":"Hello World","date":"2017-04-30T10:41:04.000Z","path":"posts/4a17b156/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://yanqinming.cn/tags/Hello-World/"},{"name":"Test","slug":"Test","permalink":"http://yanqinming.cn/tags/Test/"}]}]